/**
 * @fileoverview added by tsickle
 * Generated from: modules/common/src/transfer_http.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HTTP_INTERCEPTORS, HttpHeaders, HttpResponse } from '@angular/common/http';
import { ApplicationRef, Injectable, NgModule } from '@angular/core';
import { BrowserTransferStateModule, TransferState, makeStateKey } from '@angular/platform-browser';
import { of as observableOf } from 'rxjs';
import { filter, take, tap } from 'rxjs/operators';
/**
 * @record
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/platform-browser';
export function TransferHttpResponse() { }
if (false) {
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.body;
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.headers;
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.status;
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.statusText;
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.url;
}
/**
 * @param {?} headers
 * @return {?}
 */
function getHeadersMap(headers) {
    /** @type {?} */
    const headersMap = {};
    for (const key of headers.keys()) {
        headersMap[key] = headers.getAll(key);
    }
    return headersMap;
}
export class TransferHttpCacheInterceptor {
    /**
     * @param {?} appRef
     * @param {?} transferState
     */
    constructor(appRef, transferState) {
        this.transferState = transferState;
        this.isCacheActive = true;
        // Stop using the cache if the application has stabilized, indicating initial rendering is
        // complete.
        // tslint:disable-next-line: no-floating-promises
        appRef.isStable
            .pipe(filter((/**
         * @param {?} isStable
         * @return {?}
         */
        (isStable) => isStable)), take(1)).toPromise()
            .then((/**
         * @return {?}
         */
        () => { this.isCacheActive = false; }));
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    invalidateCacheEntry(url) {
        Object.keys(this.transferState['store'])
            .forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => key.includes(url) ? this.transferState.remove(makeStateKey(key)) : null));
    }
    /**
     * @private
     * @param {?} method
     * @param {?} url
     * @param {?} params
     * @return {?}
     */
    makeCacheKey(method, url, params) {
        // make the params encoded same as a url so it's easy to identify
        /** @type {?} */
        const encodedParams = params.keys().sort().map((/**
         * @param {?} k
         * @return {?}
         */
        k => `${k}=${params.get(k)}`)).join('&');
        /** @type {?} */
        const key = (method === 'GET' ? 'G.' : 'H.') + url + '?' + encodedParams;
        return makeStateKey(key);
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        // Stop using the cache if there is a mutating call.
        if (req.method !== 'GET' && req.method !== 'HEAD') {
            this.isCacheActive = false;
            this.invalidateCacheEntry(req.url);
        }
        if (!this.isCacheActive) {
            // Cache is no longer active. Pass the request through.
            return next.handle(req);
        }
        /** @type {?} */
        const storeKey = this.makeCacheKey(req.method, req.url, req.params);
        if (this.transferState.hasKey(storeKey)) {
            // Request found in cache. Respond using it.
            /** @type {?} */
            const response = this.transferState.get(storeKey, (/** @type {?} */ ({})));
            return observableOf(new HttpResponse({
                body: response.body,
                headers: new HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: response.url,
            }));
        }
        else {
            // Request not found in cache. Make the request and cache it.
            /** @type {?} */
            const httpEvent = next.handle(req);
            return httpEvent
                .pipe(tap((/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                if (event instanceof HttpResponse) {
                    this.transferState.set(storeKey, {
                        body: event.body,
                        headers: getHeadersMap(event.headers),
                        status: event.status,
                        statusText: event.statusText,
                        url: event.url || '',
                    });
                }
            })));
        }
    }
}
TransferHttpCacheInterceptor.ɵfac = function TransferHttpCacheInterceptor_Factory(t) { return new (t || TransferHttpCacheInterceptor)(ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵinject(ɵngcc1.TransferState)); };
TransferHttpCacheInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TransferHttpCacheInterceptor, factory: TransferHttpCacheInterceptor.ɵfac });
/** @nocollapse */
TransferHttpCacheInterceptor.ctorParameters = () => [
    { type: ApplicationRef },
    { type: TransferState }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TransferHttpCacheInterceptor, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ApplicationRef }, { type: ɵngcc1.TransferState }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    TransferHttpCacheInterceptor.prototype.isCacheActive;
    /**
     * @type {?}
     * @private
     */
    TransferHttpCacheInterceptor.prototype.transferState;
}
/**
 * An NgModule used in conjunction with `ServerTransferHttpCacheModule` to transfer cached HTTP
 * calls from the server to the client application.
 */
export class TransferHttpCacheModule {
}
TransferHttpCacheModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TransferHttpCacheModule });
TransferHttpCacheModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TransferHttpCacheModule_Factory(t) { return new (t || TransferHttpCacheModule)(); }, providers: [
        TransferHttpCacheInterceptor,
        { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
    ], imports: [[BrowserTransferStateModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TransferHttpCacheModule, { imports: function () { return [BrowserTransferStateModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TransferHttpCacheModule, [{
        type: NgModule,
        args: [{
                imports: [BrowserTransferStateModule],
                providers: [
                    TransferHttpCacheInterceptor,
                    { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
                ]
            }]
    }], null, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJfaHR0cC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbW9kdWxlcy9jb21tb24vc3JjL3RyYW5zZmVyX2h0dHAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBT0EsT0FBTyxFQUNMLGlCQUFpQixFQUdqQixXQUFXLEVBSVgsWUFBWSxFQUNiLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JFLE9BQU8sRUFDTCwwQkFBMEIsRUFFMUIsYUFBYSxFQUNiLFlBQVksRUFDYixNQUFNLDJCQUEyQixDQUFDO0FBQ25DLE9BQU8sRUFBYyxFQUFFLElBQUksWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ25EO0FBQ0c7QUFBVzs7O0FBQWQsMENBTUM7QUFDRDtBQUNZO0FBQStCLElBUHpDLG9DQUFrQjtBQUNwQjtBQUErQixJQUE3Qix1Q0FBa0M7QUFDcEM7QUFDWSxJQURWLHNDQUFnQjtBQUNsQjtBQUNRLElBRE4sMENBQW9CO0FBQ3RCO0FBR1ksSUFIVixtQ0FBYTtBQUNmO0FBQ0E7QUFDRztBQUFzQjtBQUFlO0FBQXhDLFNBQVMsYUFBYSxDQUFDLE9BQW9CO0FBQzNDO0FBQXFCLFVBQWIsVUFBVSxHQUFvQyxFQUFFO0FBQ3hELElBQUUsS0FBSyxNQUFNLEdBQUcsSUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUU7QUFDcEMsUUFBSSxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUMxQyxLQUFHO0FBQ0gsSUFDRSxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDO0FBR0QsTUFBTSxPQUFPLDRCQUE0QjtBQUFHO0FBQVE7QUFFL0M7QUFF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Q0gsQ0FBQztBQUNWLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSDt3REEzRUMsVUFBVTtvSkFDVDtBQUFDO0FBQW1CO0FBRWxCLFlBOUJLLGNBQWM7QUFBSSxZQUl6QixhQUFhO0FBQ2Q7OzsrR0FBRTtBQUFDO0FBQ0Y7QUFBUTtBQUFpQjtBQUNwQjtBQUFRLElBdUJiLHFEQUE2QjtBQUMvQjtBQUNPO0FBQWlCO0FBQWdCO0FBQ3RDLElBWW9DLHFEQUFvQztBQUFDO0FBQUU7QUFDMUU7QUFDQztBQUNtQztBQW1FdkMsTUFBTSxPQUFPLHVCQUF1QjtBQUFHO21EQVB0QyxRQUFRLFNBQUMsa0JBQ1I7RUFBTyxFQUFFLENBQUMsMEJBQTBCLENBQUMsa0JBQ3JDLFNBQVMsRUFBRSxzQkFDVCw0QkFBNEIsc0JBQzVCLEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFO0NBQVcsRUFBRSw0QkFBNEIsRUFBRTtBQUFLLEVBQUUsSUFBSSxFQUFDLG1CQUNyRixlQUNGOzs7Ozs7Ozs7Ozs7MEJBQ0k7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcbiAgSFRUUF9JTlRFUkNFUFRPUlMsXG4gIEh0dHBFdmVudCxcbiAgSHR0cEhhbmRsZXIsXG4gIEh0dHBIZWFkZXJzLFxuICBIdHRwSW50ZXJjZXB0b3IsXG4gIEh0dHBQYXJhbXMsXG4gIEh0dHBSZXF1ZXN0LFxuICBIdHRwUmVzcG9uc2Vcbn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgQXBwbGljYXRpb25SZWYsIEluamVjdGFibGUsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBCcm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZSxcbiAgU3RhdGVLZXksXG4gIFRyYW5zZmVyU3RhdGUsXG4gIG1ha2VTdGF0ZUtleVxufSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIGFzIG9ic2VydmFibGVPZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmZXJIdHRwUmVzcG9uc2Uge1xuICBib2R5PzogYW55IHwgbnVsbDtcbiAgaGVhZGVycz86IHtbazogc3RyaW5nXTogc3RyaW5nW119O1xuICBzdGF0dXM/OiBudW1iZXI7XG4gIHN0YXR1c1RleHQ/OiBzdHJpbmc7XG4gIHVybD86IHN0cmluZztcbn1cblxuZnVuY3Rpb24gZ2V0SGVhZGVyc01hcChoZWFkZXJzOiBIdHRwSGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXSB8IG51bGw+ID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGhlYWRlcnMua2V5cygpKSB7XG4gICAgaGVhZGVyc01hcFtrZXldID0gaGVhZGVycy5nZXRBbGwoa2V5KTtcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzTWFwO1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHJhbnNmZXJIdHRwQ2FjaGVJbnRlcmNlcHRvciBpbXBsZW1lbnRzIEh0dHBJbnRlcmNlcHRvciB7XG5cbiAgcHJpdmF0ZSBpc0NhY2hlQWN0aXZlID0gdHJ1ZTtcblxuICBwcml2YXRlIGludmFsaWRhdGVDYWNoZUVudHJ5KHVybDogc3RyaW5nKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy50cmFuc2ZlclN0YXRlWydzdG9yZSddKVxuICAgICAgLmZvckVhY2goa2V5ID0+IGtleS5pbmNsdWRlcyh1cmwpID8gdGhpcy50cmFuc2ZlclN0YXRlLnJlbW92ZShtYWtlU3RhdGVLZXkoa2V5KSkgOiBudWxsKTtcbiAgfVxuXG4gIHByaXZhdGUgbWFrZUNhY2hlS2V5KG1ldGhvZDogc3RyaW5nLCB1cmw6IHN0cmluZywgcGFyYW1zOiBIdHRwUGFyYW1zKTogU3RhdGVLZXk8c3RyaW5nPiB7XG4gICAgLy8gbWFrZSB0aGUgcGFyYW1zIGVuY29kZWQgc2FtZSBhcyBhIHVybCBzbyBpdCdzIGVhc3kgdG8gaWRlbnRpZnlcbiAgICBjb25zdCBlbmNvZGVkUGFyYW1zID0gcGFyYW1zLmtleXMoKS5zb3J0KCkubWFwKGsgPT4gYCR7a309JHtwYXJhbXMuZ2V0KGspfWApLmpvaW4oJyYnKTtcbiAgICBjb25zdCBrZXkgPSAobWV0aG9kID09PSAnR0VUJyA/ICdHLicgOiAnSC4nKSArIHVybCArICc/JyArIGVuY29kZWRQYXJhbXM7XG5cbiAgICByZXR1cm4gbWFrZVN0YXRlS2V5PFRyYW5zZmVySHR0cFJlc3BvbnNlPihrZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYXBwUmVmOiBBcHBsaWNhdGlvblJlZiwgcHJpdmF0ZSB0cmFuc2ZlclN0YXRlOiBUcmFuc2ZlclN0YXRlKSB7XG4gICAgLy8gU3RvcCB1c2luZyB0aGUgY2FjaGUgaWYgdGhlIGFwcGxpY2F0aW9uIGhhcyBzdGFiaWxpemVkLCBpbmRpY2F0aW5nIGluaXRpYWwgcmVuZGVyaW5nIGlzXG4gICAgLy8gY29tcGxldGUuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1mbG9hdGluZy1wcm9taXNlc1xuICAgIGFwcFJlZi5pc1N0YWJsZVxuICAgICAgLnBpcGUoXG4gICAgICAgIGZpbHRlcigoaXNTdGFibGU6IGJvb2xlYW4pID0+IGlzU3RhYmxlKSxcbiAgICAgICAgdGFrZSgxKVxuICAgICAgKS50b1Byb21pc2UoKVxuICAgICAgLnRoZW4oKCkgPT4geyB0aGlzLmlzQ2FjaGVBY3RpdmUgPSBmYWxzZTsgfSk7XG4gIH1cblxuICBpbnRlcmNlcHQocmVxOiBIdHRwUmVxdWVzdDxhbnk+LCBuZXh0OiBIdHRwSGFuZGxlcik6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICAvLyBTdG9wIHVzaW5nIHRoZSBjYWNoZSBpZiB0aGVyZSBpcyBhIG11dGF0aW5nIGNhbGwuXG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnICYmIHJlcS5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgdGhpcy5pc0NhY2hlQWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLmludmFsaWRhdGVDYWNoZUVudHJ5KHJlcS51cmwpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0NhY2hlQWN0aXZlKSB7XG4gICAgICAvLyBDYWNoZSBpcyBubyBsb25nZXIgYWN0aXZlLiBQYXNzIHRoZSByZXF1ZXN0IHRocm91Z2guXG4gICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZUtleSA9IHRoaXMubWFrZUNhY2hlS2V5KHJlcS5tZXRob2QsIHJlcS51cmwsIHJlcS5wYXJhbXMpO1xuXG4gICAgaWYgKHRoaXMudHJhbnNmZXJTdGF0ZS5oYXNLZXkoc3RvcmVLZXkpKSB7XG4gICAgICAvLyBSZXF1ZXN0IGZvdW5kIGluIGNhY2hlLiBSZXNwb25kIHVzaW5nIGl0LlxuICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnRyYW5zZmVyU3RhdGUuZ2V0KHN0b3JlS2V5LCB7fSBhcyBUcmFuc2Zlckh0dHBSZXNwb25zZSk7XG5cbiAgICAgIHJldHVybiBvYnNlcnZhYmxlT2YobmV3IEh0dHBSZXNwb25zZTxhbnk+KHtcbiAgICAgICAgYm9keTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgaGVhZGVyczogbmV3IEh0dHBIZWFkZXJzKHJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcXVlc3Qgbm90IGZvdW5kIGluIGNhY2hlLiBNYWtlIHRoZSByZXF1ZXN0IGFuZCBjYWNoZSBpdC5cbiAgICAgIGNvbnN0IGh0dHBFdmVudCA9IG5leHQuaGFuZGxlKHJlcSk7XG5cbiAgICAgIHJldHVybiBodHRwRXZlbnRcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgdGFwKChldmVudDogSHR0cEV2ZW50PHVua25vd24+KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFuc2ZlclN0YXRlLnNldChzdG9yZUtleSwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGV2ZW50LmJvZHksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVyc01hcChldmVudC5oZWFkZXJzKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGV2ZW50LnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBldmVudC5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIHVybDogZXZlbnQudXJsIHx8ICcnLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIE5nTW9kdWxlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgU2VydmVyVHJhbnNmZXJIdHRwQ2FjaGVNb2R1bGVgIHRvIHRyYW5zZmVyIGNhY2hlZCBIVFRQXG4gKiBjYWxscyBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCBhcHBsaWNhdGlvbi5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0Jyb3dzZXJUcmFuc2ZlclN0YXRlTW9kdWxlXSxcbiAgcHJvdmlkZXJzOiBbXG4gICAgVHJhbnNmZXJIdHRwQ2FjaGVJbnRlcmNlcHRvcixcbiAgICB7cHJvdmlkZTogSFRUUF9JTlRFUkNFUFRPUlMsIHVzZUV4aXN0aW5nOiBUcmFuc2Zlckh0dHBDYWNoZUludGVyY2VwdG9yLCBtdWx0aTogdHJ1ZX0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIFRyYW5zZmVySHR0cENhY2hlTW9kdWxlIHt9XG4iXX0=